"use strict";exports.__esModule=true;exports.stackPush=stackPush;exports.stackPop=stackPop;exports.traceFn=traceFn;exports.traceAsyncFn=traceAsyncFn;exports.tracer=void 0;var _api=_interopRequireDefault(require("@opentelemetry/api"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}const tracer=_api.default.trace.getTracer('next',"10.0.6");exports.tracer=tracer;const compilerStacks=new WeakMap();function stackPush(compiler,spanName,attrs){let stack=compilerStacks.get(compiler);let span;if(!stack){compilerStacks.set(compiler,stack=[]);span=tracer.startSpan(spanName,attrs?attrs():undefined);}else{const parent=stack[stack.length-1];tracer.withSpan(parent,()=>{span=tracer.startSpan(spanName,attrs?attrs():undefined);});}stack.push(span);return span;}function stackPop(compiler,span){span.end();let stack=compilerStacks.get(compiler);if(!stack){console.warn('Attempted to pop from non-existent stack. Compiler reference must be bad.');return;}const poppedSpan=stack.pop();if(poppedSpan!==span){stack.push(poppedSpan);const spanIdx=stack.indexOf(span);console.warn('Attempted to pop span that was not at top of stack.');if(spanIdx!==-1){console.info(`Span was found at index ${spanIdx} with stack size ${stack.length}`);}}}function traceFn(span,fn){return tracer.withSpan(span,()=>{try{return fn();}finally{span.end();}});}function traceAsyncFn(span,fn){return tracer.withSpan(span,async()=>{try{return await fn();}finally{span.end();}});}
//# sourceMappingURL=tracer.js.map