{"version":3,"sources":["../../build/tracer.ts"],"names":["tracer","api","trace","getTracer","process","env","__NEXT_VERSION","compilerStacks","WeakMap","stackPush","compiler","spanName","attrs","stack","get","span","set","startSpan","undefined","parent","length","withSpan","push","stackPop","end","console","warn","poppedSpan","pop","spanIdx","indexOf","info","traceFn","fn","traceAsyncFn"],"mappings":"2KAAA,+D,mFAEO,KAAMA,CAAAA,MAAM,CAAGC,aAAIC,KAAJ,CAAUC,SAAV,CAAoB,MAApB,CAA4BC,OAAO,CAACC,GAAR,CAAYC,cAAxC,CAAf,C,sBAEP,KAAMC,CAAAA,cAAc,CAAG,GAAIC,CAAAA,OAAJ,EAAvB,CAEO,QAASC,CAAAA,SAAT,CAAmBC,QAAnB,CAAkCC,QAAlC,CAAoDC,KAApD,CAAsE,CAC3E,GAAIC,CAAAA,KAAK,CAAGN,cAAc,CAACO,GAAf,CAAmBJ,QAAnB,CAAZ,CACA,GAAIK,CAAAA,IAAJ,CAEA,GAAI,CAACF,KAAL,CAAY,CACVN,cAAc,CAACS,GAAf,CAAmBN,QAAnB,CAA8BG,KAAK,CAAG,EAAtC,EACAE,IAAI,CAAGf,MAAM,CAACiB,SAAP,CAAiBN,QAAjB,CAA2BC,KAAK,CAAGA,KAAK,EAAR,CAAaM,SAA7C,CAAP,CACD,CAHD,IAGO,CACL,KAAMC,CAAAA,MAAM,CAAGN,KAAK,CAACA,KAAK,CAACO,MAAN,CAAe,CAAhB,CAApB,CACApB,MAAM,CAACqB,QAAP,CAAgBF,MAAhB,CAAwB,IAAM,CAC5BJ,IAAI,CAAGf,MAAM,CAACiB,SAAP,CAAiBN,QAAjB,CAA2BC,KAAK,CAAGA,KAAK,EAAR,CAAaM,SAA7C,CAAP,CACD,CAFD,EAGD,CAEDL,KAAK,CAACS,IAAN,CAAWP,IAAX,EACA,MAAOA,CAAAA,IAAP,CACD,CAEM,QAASQ,CAAAA,QAAT,CAAkBb,QAAlB,CAAiCK,IAAjC,CAA4C,CACjDA,IAAI,CAACS,GAAL,GAEA,GAAIX,CAAAA,KAAK,CAAGN,cAAc,CAACO,GAAf,CAAmBJ,QAAnB,CAAZ,CACA,GAAI,CAACG,KAAL,CAAY,CACVY,OAAO,CAACC,IAAR,CACE,2EADF,EAGA,OACD,CACD,KAAMC,CAAAA,UAAU,CAAGd,KAAK,CAACe,GAAN,EAAnB,CACA,GAAID,UAAU,GAAKZ,IAAnB,CAAyB,CACvBF,KAAK,CAACS,IAAN,CAAWK,UAAX,EACA,KAAME,CAAAA,OAAO,CAAGhB,KAAK,CAACiB,OAAN,CAAcf,IAAd,CAAhB,CACAU,OAAO,CAACC,IAAR,CAAa,qDAAb,EACA,GAAIG,OAAO,GAAK,CAAC,CAAjB,CAAoB,CAClBJ,OAAO,CAACM,IAAR,CACG,2BAA0BF,OAAQ,oBAAmBhB,KAAK,CAACO,MAAO,EADrE,EAGD,CACF,CACF,CAEM,QAASY,CAAAA,OAAT,CACLjB,IADK,CAELkB,EAFK,CAGU,CACf,MAAOjC,CAAAA,MAAM,CAACqB,QAAP,CAAgBN,IAAhB,CAAsB,IAAM,CACjC,GAAI,CACF,MAAOkB,CAAAA,EAAE,EAAT,CACD,CAFD,OAEU,CACRlB,IAAI,CAACS,GAAL,GACD,CACF,CANM,CAAP,CAOD,CAEM,QAASU,CAAAA,YAAT,CACLnB,IADK,CAELkB,EAFK,CAGmB,CACxB,MAAOjC,CAAAA,MAAM,CAACqB,QAAP,CAAgBN,IAAhB,CAAsB,SAAY,CACvC,GAAI,CACF,MAAO,MAAMkB,CAAAA,EAAE,EAAf,CACD,CAFD,OAEU,CACRlB,IAAI,CAACS,GAAL,GACD,CACF,CANM,CAAP,CAOD","sourcesContent":["import api, { Span } from '@opentelemetry/api'\n\nexport const tracer = api.trace.getTracer('next', process.env.__NEXT_VERSION)\n\nconst compilerStacks = new WeakMap()\n\nexport function stackPush(compiler: any, spanName: string, attrs?: any): any {\n  let stack = compilerStacks.get(compiler)\n  let span\n\n  if (!stack) {\n    compilerStacks.set(compiler, (stack = []))\n    span = tracer.startSpan(spanName, attrs ? attrs() : undefined)\n  } else {\n    const parent = stack[stack.length - 1]\n    tracer.withSpan(parent, () => {\n      span = tracer.startSpan(spanName, attrs ? attrs() : undefined)\n    })\n  }\n\n  stack.push(span)\n  return span\n}\n\nexport function stackPop(compiler: any, span: any) {\n  span.end()\n\n  let stack = compilerStacks.get(compiler)\n  if (!stack) {\n    console.warn(\n      'Attempted to pop from non-existent stack. Compiler reference must be bad.'\n    )\n    return\n  }\n  const poppedSpan = stack.pop()\n  if (poppedSpan !== span) {\n    stack.push(poppedSpan)\n    const spanIdx = stack.indexOf(span)\n    console.warn('Attempted to pop span that was not at top of stack.')\n    if (spanIdx !== -1) {\n      console.info(\n        `Span was found at index ${spanIdx} with stack size ${stack.length}`\n      )\n    }\n  }\n}\n\nexport function traceFn<T extends (...args: unknown[]) => ReturnType<T>>(\n  span: Span,\n  fn: T\n): ReturnType<T> {\n  return tracer.withSpan(span, () => {\n    try {\n      return fn()\n    } finally {\n      span.end()\n    }\n  })\n}\n\nexport function traceAsyncFn<T extends (...args: unknown[]) => ReturnType<T>>(\n  span: Span,\n  fn: T\n): Promise<ReturnType<T>> {\n  return tracer.withSpan(span, async () => {\n    try {\n      return await fn()\n    } finally {\n      span.end()\n    }\n  })\n}\n"]}